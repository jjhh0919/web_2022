# 7장 연산자

---

### 산술 연산자

* 피연산자를 대상으로 수학적 계산을 통해 새로운 숫자 값을 만듬
* 산술 연산이 불가능한 경우, NaN을 반환
* 피연산자의 개수에 따라 이항 산술 연산자와 단항 산술 연산자로 구분

#### 이항 산술 연산자

* 2개의 피연산자를 산술 연산하여 숫자 값을 만듬
* 부수 효과가 없음(피연산자의 값이 바뀌는 경우는 없고 언제나 새로운 값을 만듬)

#### 단항 산술 연산자

* 1개의 피연산자를 산술 연산하여 숫자 값을 만듬
* 증가/감소(++/--) 연산자는 피연산자의 값을 변경하는 부수 효과가 있음(피연산자의 값을 변경하는 암묵적 할당이 이루어짐)
* +단항 연산자 : 숫자 타입이 아닌 피연산자를 사용하면 피연산자를 숫자 타입으로 변환하여 반환
* -단항 연산자 : 피연산자의 부호를 반전한 값을 반환

```
증가/감소 연산자의 위치 의미

전위 증가/감소 연산자는 먼저 피연산자의 값을 증가/감소시킨 후, 다른 연산을 수행

후위 증가/감소 연산자는 먼저 다른 연산을 수행한 후, 피연산자의 값을 증가, 감소
```

#### 문자열 연결 연산자

* +연산자 : 피연산자 중 하나 이상의 문자열인 경우 문자열 연결 연산자로 동작(그 외의 경우는 산술 연산자)
* 암묵적 타입 변환, 타입 강제 변환이 발생 가능

### 할당 연산자

* 우항에 있는 피연산자의 평과 결과를 좌항에 있는 변수에 할당
* 좌항의 변수에 값을 할당하므로 변수 값이 변하는 부수 효과가 있음

### 비교 연산자

* 좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값으로 반환
* 제어문의 조건식에서 주로 사용

#### 동등/일치 비교 연산자\

* ==, != 연산자 : 값을 비교
* ===, !== 연산자 : 값과 타입을 비교
* NaN === NaN; // false(NaN은 자신과 일치하지 않는 유일한 값)

#### 대소 관계 비교 연산자

* 크기를 비교하여 불리언 값을 반환 : >, <, >=, <=

#### 삼항 조건 연산자

* 조건식의 평가 결과에 따라 반환한 값을 결정
* 조건식 ? true일 때 반환할 값 : false일 때 반환할 값
* 값으로 평가할 수 있는 표현식인 문

```
삼항 조건 연산자 표현식은 값처럼 사용 가능

if ... else 문은 값처럼 사용할 수 없음
```

### 논리 연산자

* 우항과 좌항의 피연산자를 논리 연산
* || 연산자 : 논리합(OR)
* && 연산자 : 논리곱(AND)
* ! 연산자 : 부정(NOT)

### 쉼표 연산자

* 왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평과 결과를 반환

### 그룹 연산자

* 소괄호로 피연산자를 감쌈
* 자신의 피연산자인 표현식을 가장 먼저 평가
* 연산자의 우선순위를 조절(그룹 연산자의 우선순위가 가장 높음)

### typeof 연산자

* 피연산자의 데이터 타입을 문자열로 반환
* string, number, boolean, undefined, symbol, object, function 중 하나 반환
* null 값을 연산해 보면 object 반환(자바스크립트의 버그지만 기존의 코드들에 영향을 줄 수 있기 때문에 수정하지 못하고 있음)
* 선언하지 않은 식별자는 에러가 발생하지 않고 undefined 반환

### 지수 연산자

* ES7에서 도입
* num1**num2
* num1을 밑으로, num2를 지수로 거듭제고하여 숫자 값을 반환
* 이전에는 Math.pow 메서드를 사용
* 음수를 거듭제곱의 밑으로 계산하려면 괄호로 묶음

### 그 외의 연산자

* ?. 연산자 : 옵셔널 체이닝 연산자
* ?? 연산자 : null 병합 연산자
* delete 연산자 : 프로퍼티 삭제
* new 연산자 : 생성자 함수를 호출할 때 사용하여 인스턴스를 생성
* instanceof 연산자 : 좌변의 객체가 우변의 생성자 함수와 연결된 인스턴스인지 판별
* in 연산자 : 프로퍼티 존재 확인

### 연산자의 부수 효과

* 대부분의 연산자는 다른 코드에 영향 X
* 할당연산자(=), 증가/감소 연산자(++/--), delete 연산자

### 연산자 우선순위

* 종류가 많아서 연산자 우선순위를 모두 기억하기 어려움
* 기억에 의존하기보다는 연산자 우선순위가 가장 높은 그룹 연산자를 사용하여 우선순위를 명시적으로 조절하는 것을 권장

```
// 1순위
()

// 2순위
new(매개변수 존재), ., [](프로퍼티 접근), ()(함수 호출), ?.(옵셔널 체이닝 연산자)

// 3순위
new(매개변수 미존재)

// 4순위
x++, x--

// 5순위
!x, +x, -x, ++x, --x, typeof, delete

// 6순위
**(이항 연산자 중에서 우선순위가 가장 높다)

// 7순위
*, /, %

// 8순위
+, -

// 9순위
<, <=, >, >=, in, instanceof

// 10순위
==, !=, ===, !==

// 11순위
??(null 병합 연산자)

// 12순위
&&

// 13순위
||

// 14순위
? ... : ...

// 15순위
할당 연산자(=, +=, -=, ...)

// 16순위
,
```

### 연산자 결합 순서

* 연산자의 어느 쪽(좌항 또는 우항)부터 평가를 수행할 건인지를 나타내는 순서

```
// 좌항 → 우항
+, -, /, %, <, <=, >, >=, &&, ||, ., [], (), ??, ?., in, instanceof

//우항 → 좌항
++, --, 할당 연산자(=, +=, -=, ...), !x, +x, -x, ++x, --x, typeof, delete, ? ... : ..., **
```