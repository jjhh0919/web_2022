# 17장 생성자 함수에 의한 객체 생성

---

### Object 생성자 함수

* 특별한 이유가 없다면 그다지 유용하지 않은 방법
* new 연산자와 함께 Object 생성자 함수를 호출 => 빈 객체를 생성하여 반환
* 빈 객체를 생성한 이후 프로퍼티 또는 메서드를 추가하여 객체를 완성
* 생성자 함수 : new 연산자와 함께 호출하여 객체를 생성하는 함수
* 인스턴스 : 생성자 함수에 의해 생성된 객체
* 자바스크립트의 빌트인 생성자 함수 : Object, String, Number, Boolean, Function, Array, Date, RegExp, Promise 등

### 생성자 함수

#### 객체 리터럴에 의한 객체 생성 방식의 문제점

* 직관적이고 간편함
* 단 하나만의 객체만 생성 => 동일한 프로퍼티를 갖는 객체를 여러 개 생성해야 하는 경우 매번 같은 프로퍼티를 기술해야 하기 때문에 비효율적

#### 생성자 함수에 의한 객체 생성 방식의 장점

* 객체(인스턴스)를 생성하기 위한 템플릿(클래스)처럼 생성자 함수를 사용하여 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성 가능
* 생성자 함수로 동작 => 형식이 정해져 있는 것이 아니라 일반 함수와 동일한 방법으로 생성자 함수를 정의하고 new 연산자와 함께 호출

#### 생성자 함수의 인스턴스 생성 과정

* 생성자 함수의 역할 => 프로퍼티 구조가 동일한 인스턴스를 생성하기 위한 템플릿(클래스)으로서 동작
* 인스턴스를 생성 + 생성된 인스턴스를 초기화
* 인스턴스 생성과 this 바인딩
* 인스턴스 초기화
* 인스턴스 반환

#### 내부 메서드[[Call]]과 [[Construct]]

* 함수는 객체이지만 일반 객체와는 다름 => 일반 객체는 호출할 수 없지만 함수는 호출 가능
* 함수 객체는 일반 객체가 가지고 있는 내부 슬롯과 내부 메서드 + 함수로서 동작하기 위해 함수 객체만을 위한 [[Enviroment]], [[FormalParameters]] 등의 내부 슬롯과 [[Call]], [[Construct]] 같은 내부 메서드를 추가로 가짐
* 함수가 일반 함수로서 호출 => [[Call]]이 호출
* new 연산자와 함께 생성자 함수로서 호출 => [[Construct]]가 호출

#### constructor와 non-constructor의 구분

* constructor : 함수 선언문, 함수 표현식, 클래스(클래스도 함수)
* non-constructor : 메서드, 화살표 함수
* non-constructor인 함수 객체를 생성자 함수로서 호출하면 에러가 발생

#### new 연산자

* new 연산자와 함께 함수를 호출하면 해당 함수는 생성자 함수로 동작
* new 연산자와 함께 호출하는 함수는 constructor이어야 함
* 일반 함수와 생성자 함수에 특별한 형식의 차이 X => 생성자 함수는 일반적으로 첫 문자를 대문자로 기술(파스칼 케이스)로 명명하여 구분

#### new.target

* 생성자 함수가 new 연산자 없이 호출되는 것을 방지하기 위해 ES6에서 지원
* this와 유사하게 constructor인 모든 함수 내부에서 암묵적인 지역 변수와 같이 사용되며 메타 프로퍼티라고 부름
* 함수 내부에서 new.target을 사용 => new 연산자와 함께 생성자 함수로서 호출되었는지 확인 가능
* new 연산자와 함께 생성자 함수로서 호출 => 함수 자신
* new 연산자 없이 일반함수로서 호출 => undefined